<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emmaus School Navigation</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background-color: #f3f4f6;
        }
        .app {
            width: 100vw;
            height: 100vh;
            background-color: #f3f4f6;
            display: flex;
        }
        
        /* Collapsible Sidebar */
        .sidebar {
            width: 320px;
            background: white;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            padding: 1rem;
            overflow-y: auto;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .sidebar.collapsed {
            width: 0;
            padding: 0;
            overflow: hidden;
        }
        
        .sidebar-toggle {
            position: absolute;
            top: 1rem;
            right: -12px;
            width: 24px;
            height: 24px;
            background: #3b82f6;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            z-index: 10;
            transition: all 0.2s ease;
        }
        
        .sidebar-toggle:hover {
            background: #2563eb;
            transform: scale(1.1);
        }
        
        .main-content {
            flex: 1;
            padding: 1rem;
            overflow: auto;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        .canvas-container {
            background: white;
            border-radius: 0.5rem;
            border: 2px solid #d1d5db;
            overflow: auto;
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        canvas {
            display: block;
            max-width: 100%;
            max-height: 100%;
            transition: transform 0.2s ease;
        }
        
        /* Fullscreen mode during navigation */
        .fullscreen-mode {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 100;
            background: white;
            display: flex;
            flex-direction: column;
        }
        
        .fullscreen-header {
            padding: 1rem;
            background: #f3f4f6;
            border-bottom: 1px solid #d1d5db;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .fullscreen-canvas {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: auto;
        }
        
        .zoom-controls {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: white;
            border-radius: 0.5rem;
            border: 1px solid #d1d5db;
            padding: 0.5rem;
            display: flex;
            gap: 0.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            z-index: 10;
        }
        
        .zoom-btn {
            width: 36px;
            height: 36px;
            border: 1px solid #d1d5db;
            background: white;
            border-radius: 0.375rem;
            font-size: 1.125rem;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .zoom-btn:hover {
            background: #f3f4f6;
        }
        
        .zoom-level {
            min-width: 60px;
            text-align: center;
            font-size: 0.875rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Keep all your existing styles below... */
        
        .school-header {
            background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
            color: white;
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            border-left: 6px solid #10b981;
        }
        
        /* ... (Keep ALL your existing CSS styles exactly as they were) ... */
        
        .btn-primary {
            background-color: #3b82f6;
            color: white;
        }
        .btn-primary:hover {
            background-color: #2563eb;
        }
        .btn-success {
            background-color: #10b981;
            color: white;
        }
        .btn-success:hover {
            background-color: #059669;
        }
        .btn-danger {
            background-color: #ef4444;
            color: white;
        }
        .btn-danger:hover {
            background-color: #dc2626;
        }
        .btn-secondary {
            background-color: #6b7280;
            color: white;
        }
        .btn-secondary:hover {
            background-color: #4b5563;
        }
        .btn-warning {
            background-color: #f59e0b;
            color: white;
        }
        .btn-warning:hover {
            background-color: #d97706;
        }
        .btn-info {
            background-color: #06b6d4;
            color: white;
        }
        .btn-info:hover {
            background-color: #0891b2;
        }
        
        .mode-buttons {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
        }
        
        .path-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.875rem;
            background-color: #f3f4f6;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            margin-bottom: 0.25rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .scroll-container {
            max-height: 160px;
            overflow-y: auto;
            border: 1px solid #e5e7eb;
            border-radius: 0.375rem;
            padding: 0.25rem;
        }
        
        select, input, textarea {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            margin-bottom: 0.5rem;
        }
        
        .current-position-marker {
            position: absolute;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #3b82f6;
            border: 3px solid white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            z-index: 100;
            pointer-events: none;
            animation: pulse 2s infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
            font-weight: bold;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .flex { display: flex; }
        .gap-2 { gap: 0.5rem; }
        .w-full { width: 100%; }
        .flex-1 { flex: 1; }
        .justify-between { justify-content: space-between; }
        .items-center { align-items: center; }
        .text-sm { font-size: 0.875rem; }
        .text-xs { font-size: 0.75rem; }
        .mb-2 { margin-bottom: 0.5rem; }
        .mb-4 { margin-bottom: 1rem; }
        .p-2 { padding: 0.5rem; }
        .p-4 { padding: 1rem; }
        .rounded { border-radius: 0.375rem; }
        .bg-gray-200 { background-color: #e5e7eb; }
        .bg-blue-500 { background-color: #3b82f6; }
        .text-white { color: white; }
        .text-gray-600 { color: #4b5563; }
        .text-gray-800 { color: #1f2937; }
        .cursor-grab { cursor: grab; }
        .cursor-grabbing { cursor: grabbing; }
        .hidden { display: none; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        // Icon components
        const UploadIcon = () => React.createElement('span', { className: 'icon' }, 'ðŸ“¤');
        const SaveIcon = () => React.createElement('span', { className: 'icon' }, 'ðŸ’¾');
        const NavigationIcon = () => React.createElement('span', { className: 'icon' }, 'ðŸ§­');
        const TrashIcon = () => React.createElement('span', { className: 'icon' }, 'ðŸ—‘ï¸');
        const PinIcon = () => React.createElement('span', { className: 'icon' }, 'ðŸ“');
        const PlayIcon = () => React.createElement('span', { className: 'icon' }, 'â–¶ï¸');
        const ZoomInIcon = () => React.createElement('span', { className: 'icon' }, 'âž•');
        const ZoomOutIcon = () => React.createElement('span', { className: 'icon' }, 'âž–');
        const ResetZoomIcon = () => React.createElement('span', { className: 'icon' }, 'ðŸ”„');
        const WalkIcon = () => React.createElement('span', { className: 'icon' }, 'ðŸš¶');
        const StepIcon = () => React.createElement('span', { className: 'icon' }, 'ðŸ‘£');
        const CompassIcon = () => React.createElement('span', { className: 'icon' }, 'ðŸ§­');
        const SensorIcon = () => React.createElement('span', { className: 'icon' }, 'âš¡');
        const PauseIcon = () => React.createElement('span', { className: 'icon' }, 'â¸ï¸');
        const LoginIcon = () => React.createElement('span', { className: 'icon' }, 'ðŸ”');
        const LogoutIcon = () => React.createElement('span', { className: 'icon' }, 'ðŸšª');
        const IOSPermissionIcon = () => React.createElement('span', { className: 'icon' }, 'ðŸ“±');
        const SchoolIcon = () => React.createElement('span', { className: 'icon' }, 'ðŸ«');
        const ExportIcon = () => React.createElement('span', { className: 'icon' }, 'ðŸ“¥');
        const ImportIcon = () => React.createElement('span', { className: 'icon' }, 'ðŸ“¤');
        const BackupIcon = () => React.createElement('span', { className: 'icon' }, 'ðŸ’¾');
        const ResetIcon = () => React.createElement('span', { className: 'icon' }, 'ðŸ—‘ï¸');
        const StorageIcon = () => React.createElement('span', { className: 'icon' }, 'ðŸ’½');
        const CollapseIcon = () => React.createElement('span', { className: 'icon' }, 'â—€');
        const ExpandIcon = () => React.createElement('span', { className: 'icon' }, 'â–¶');

        const FloorPlanNavigator = () => {
            // NEW STATE: Collapsible sidebar and fullscreen mode
            const [isSidebarCollapsed, setIsSidebarCollapsed] = useState(false);
            const [isFullscreenMode, setIsFullscreenMode] = useState(false);
            
            // KEEP ALL YOUR EXISTING STATE VARIABLES EXACTLY AS THEY WERE
            const [isLiveNavigation, setIsLiveNavigation] = useState(false);
            const [isMotionTracking, setIsMotionTracking] = useState(false);
            const [stepCount, setStepCount] = useState(0);
            const [heading, setHeading] = useState(0);
            const [distanceMeters, setDistanceMeters] = useState(0);
            const [currentPosition, setCurrentPosition] = useState({ x: 400, y: 300 });
            const [currentDirection, setCurrentDirection] = useState('E');
            const [pxPerMeter, setPxPerMeter] = useState(60);
            const [isMotionAvailable, setIsMotionAvailable] = useState(false);
            const [sensorStatus, setSensorStatus] = useState('Checking sensors...');
            const [isUsingDeviceOrientation, setIsUsingDeviceOrientation] = useState(false);
            const [lastMag, setLastMag] = useState(0);
            const [lastStepTime, setLastStepTime] = useState(0);
            const [threshold, setThreshold] = useState(1.2);
            const [listeningMotion, setListeningMotion] = useState(false);
            const [listeningOrient, setListeningOrient] = useState(false);
            const [liveNavPath, setLiveNavPath] = useState([]);
            const [isOnLivePath, setIsOnLivePath] = useState(true);
            const [nextLiveWaypoint, setNextLiveWaypoint] = useState(0);
            const [livePathProgress, setLivePathProgress] = useState(0);
            const [livePathDistance, setLivePathDistance] = useState(0);
            
            // iOS Permission State
            const [isIOS, setIsIOS] = useState(false);
            const [motionPermissionGranted, setMotionPermissionGranted] = useState(false);
            const [orientationPermissionGranted, setOrientationPermissionGranted] = useState(false);
            const [isRequestingPermission, setIsRequestingPermission] = useState(false);

            // EXISTING STATE
            const [floorPlan, setFloorPlan] = useState(null);
            const [mode, setMode] = useState('navigate');
            const [locations, setLocations] = useState([]);
            const [paths, setPaths] = useState([]);
            const [currentPath, setCurrentPath] = useState([]);
            const [trainingFrom, setTrainingFrom] = useState('');
            const [trainingTo, setTrainingTo] = useState('');
            const [navigateFrom, setNavigateFrom] = useState('');
            const [navigateTo, setNavigateTo] = useState('');
            const [activePath, setActivePath] = useState(null);
            const [isNavigating, setIsNavigating] = useState(false);
            const [currentStep, setCurrentStep] = useState(0);
            const [addingLocation, setAddingLocation] = useState(false);
            const [newLocationName, setNewLocationName] = useState('');
            const [pendingLocation, setPendingLocation] = useState(null);
            const [trainingInstructions] = useState(['Walk straight', 'Turn left', 'Turn right', 'Continue straight']);
            const [currentInstruction, setCurrentInstruction] = useState('');
            const [pathInstructions, setPathInstructions] = useState([]);
            const [newPathName, setNewPathName] = useState('');
            const [zoom, setZoom] = useState(1);
            const [offset, setOffset] = useState({ x: 0, y: 0 });
            const [isDragging, setIsDragging] = useState(false);
            const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
            const [selectedPathIndex, setSelectedPathIndex] = useState(null);
            const [isAdmin, setIsAdmin] = useState(false);
            const [username, setUsername] = useState('');
            const [password, setPassword] = useState('');
            const [showLogin, setShowLogin] = useState(false);
            const [deviceType, setDeviceType] = useState('desktop');
            
            // Data management state
            const [lastSaveTime, setLastSaveTime] = useState(null);
            const [isSaving, setIsSaving] = useState(false);
            const [showDataManagement, setShowDataManagement] = useState(false);
            const [autoSaveEnabled, setAutoSaveEnabled] = useState(true);
            const [saveNotification, setSaveNotification] = useState('');
            const [jsonDataLoaded, setJsonDataLoaded] = useState(false);
            const [storageStatus, setStorageStatus] = useState('Checking storage...');

            const canvasRef = useRef(null);
            const fileInputRef = useRef(null);
            const positionMarkerRef = useRef(null);
            const importFileInputRef = useRef(null);
            const saveTimeoutRef = useRef(null);

            // =============================================
            // NEW FUNCTIONS: Auto-fit and sidebar toggle
            // =============================================
            
            const toggleSidebar = () => {
                setIsSidebarCollapsed(!isSidebarCollapsed);
            };
            
            const fitCanvasToScreen = () => {
                if (!canvasRef.current || !floorPlan) return;
                
                const canvas = canvasRef.current;
                const container = canvas.parentElement;
                
                if (!container) return;
                
                // Get container dimensions
                const containerWidth = container.clientWidth;
                const containerHeight = container.clientHeight;
                
                // Create an image to get dimensions
                const img = new Image();
                img.onload = () => {
                    const imgWidth = img.width;
                    const imgHeight = img.height;
                    
                    // Calculate scale to fit container
                    const scaleX = containerWidth / imgWidth;
                    const scaleY = containerHeight / imgHeight;
                    const scale = Math.min(scaleX, scaleY, 5); // Cap at 5x zoom
                    
                    // Calculate center offset
                    const offsetX = (containerWidth - imgWidth * scale) / 2;
                    const offsetY = (containerHeight - imgHeight * scale) / 2;
                    
                    setZoom(scale);
                    setOffset({ x: offsetX, y: offsetY });
                };
                img.src = floorPlan;
            };
            
            // =============================================
            // MODIFIED NAVIGATION START FUNCTION
            // =============================================
            
            const startNavigation = () => {
                if (!navigateFrom || !navigateTo) {
                    alert('Please select both "From" and "To" locations');
                    return;
                }

                const path = paths.find(p => 
                    p.from === navigateFrom && p.to === navigateTo
                );

                if (!path) {
                    alert(`No path found between "${navigateFrom}" and "${navigateTo}"`);
                    return;
                }

                if (!path.path || path.path.length === 0) {
                    alert('Selected path has no route points. Please train this path first.');
                    return;
                }

                setActivePath(path);
                setIsNavigating(true);
                setCurrentStep(0);
                
                // Collapse sidebar and enter fullscreen mode
                setIsSidebarCollapsed(true);
                setIsFullscreenMode(true);
                
                // Fit canvas to screen after a short delay
                setTimeout(() => {
                    fitCanvasToScreen();
                }, 100);
                
                drawCanvas();
                
                alert(`Navigation started from "${navigateFrom}" to "${navigateTo}"! Sidebar collapsed for better view.`);
            };
            
            const stopNavigation = () => {
                setIsNavigating(false);
                setIsLiveNavigation(false);
                setActivePath(null);
                setCurrentStep(0);
                setIsFullscreenMode(false);
            };
            
            const exitFullscreen = () => {
                setIsFullscreenMode(false);
                setIsSidebarCollapsed(false);
            };
            
            // =============================================
            // KEEP ALL YOUR EXISTING FUNCTIONS EXACTLY AS THEY WERE
            // =============================================
            
            const drawCanvas = () => {
                const canvas = canvasRef.current;
                if (!canvas || !floorPlan) return;

                const ctx = canvas.getContext('2d');
                const img = new Image();
                img.onload = () => {
                    const displayWidth = img.width * zoom;
                    const displayHeight = img.height * zoom;
                    
                    canvas.width = displayWidth;
                    canvas.height = displayHeight;
                    
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.save();
                    ctx.translate(offset.x, offset.y);
                    
                    ctx.drawImage(img, 0, 0, displayWidth, displayHeight);

                    locations.forEach(loc => {
                        ctx.fillStyle = '#3b82f6';
                        ctx.beginPath();
                        ctx.arc(loc.x * zoom, loc.y * zoom, 8 * zoom, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.fillStyle = '#000';
                        ctx.font = `${14 * zoom}px Arial`;
                        ctx.fillText(loc.name, loc.x * zoom + 12 * zoom, loc.y * zoom + 5 * zoom);
                    });

                    if (pendingLocation) {
                        ctx.fillStyle = '#10b981';
                        ctx.beginPath();
                        ctx.arc(pendingLocation.x * zoom, pendingLocation.y * zoom, 10 * zoom, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2 * zoom;
                        ctx.stroke();
                    }

                    if (mode === 'train' && currentPath.length > 0) {
                        ctx.strokeStyle = '#10b981';
                        ctx.lineWidth = 3 * zoom;
                        ctx.beginPath();
                        ctx.moveTo(currentPath[0].x * zoom, currentPath[0].y * zoom);
                        currentPath.forEach(point => ctx.lineTo(point.x * zoom, point.y * zoom));
                        ctx.stroke();
                        
                        currentPath.forEach((point, index) => {
                            ctx.fillStyle = '#ef4444';
                            ctx.beginPath();
                            ctx.arc(point.x * zoom, point.y *zoom, 5 * zoom, 0, 2 * Math.PI);
                            ctx.fill();
                            
                            ctx.fillStyle = '#000';
                            ctx.font = `${12 * zoom}px Arial`;
                            ctx.fillText(`${index + 1}`, point.x * zoom + 8 * zoom, point.y * zoom + 5 * zoom);
                        });
                        
                        if (trainingFrom) {
                            const fromLoc = locations.find(l => l.name === trainingFrom);
                            if (fromLoc) {
                                ctx.fillStyle = '#10b981';
                                ctx.beginPath();
                                ctx.arc(fromLoc.x * zoom, fromLoc.y * zoom, 12 * zoom, 0, 2 * Math.PI);
                                ctx.fill();
                                ctx.strokeStyle = '#fff';
                                ctx.lineWidth = 2 * zoom;
                                ctx.stroke();
                            }
                        }
                        
                        if (trainingTo) {
                            const toLoc = locations.find(l => l.name === trainingTo);
                            if (toLoc) {
                                ctx.fillStyle = '#ef4444';
                                ctx.beginPath();
                                ctx.arc(toLoc.x * zoom, toLoc.y * zoom, 12 * zoom, 0, 2 * Math.PI);
                                ctx.fill();
                                ctx.strokeStyle = '#fff';
                                ctx.lineWidth = 2 * zoom;
                                ctx.stroke();
                            }
                        }
                    }

                    if (activePath && activePath.path && activePath.path.length > 0) {
                        ctx.strokeStyle = '#ef4444';
                        ctx.lineWidth = 4 * zoom;
                        ctx.lineJoin = 'round';
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        
                        if (activePath.path[0]) {
                            ctx.moveTo(activePath.path[0].x * zoom, activePath.path[0].y * zoom);
                        }
                        
                        for (let i = 1; i < activePath.path.length; i++) {
                            if (activePath.path[i]) {
                                ctx.lineTo(activePath.path[i].x * zoom, activePath.path[i].y * zoom);
                            }
                        }
                        ctx.stroke();
                        
                        activePath.path.forEach((point, index) => {
                            if (point) {
                                ctx.fillStyle = '#ef4444';
                                ctx.beginPath();
                                ctx.arc(point.x * zoom, point.y * zoom, 6 * zoom, 0, 2 * Math.PI);
                                ctx.fill();
                                ctx.strokeStyle = '#fff';
                                ctx.lineWidth = 2 * zoom;
                                ctx.stroke();
                                
                                ctx.fillStyle = '#fff';
                                ctx.font = `bold ${10 * zoom}px Arial`;
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.fillText(`${index + 1}`, point.x * zoom, point.y * zoom);
                            }
                        });
                        
                        if (activePath.from && activePath.to) {
                            const fromLoc = locations.find(l => l.name === activePath.from);
                            const toLoc = locations.find(l => l.name === activePath.to);
                            
                            if (fromLoc) {
                                ctx.fillStyle = '#10b981';
                                ctx.beginPath();
                                ctx.arc(fromLoc.x * zoom, fromLoc.y * zoom, 15 * zoom, 0, 2 * Math.PI);
                                ctx.fill();
                                ctx.strokeStyle = '#fff';
                                ctx.lineWidth = 3 * zoom;
                                ctx.stroke();
                                
                                ctx.fillStyle = '#fff';
                                ctx.font = `bold ${12 * zoom}px Arial`;
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.fillText('START', fromLoc.x * zoom, fromLoc.y * zoom);
                            }
                            
                            if (toLoc) {
                                ctx.fillStyle = '#ef4444';
                                ctx.beginPath();
                                ctx.arc(toLoc.x * zoom, toLoc.y * zoom, 15 * zoom, 0, 2 * Math.PI);
                                ctx.fill();
                                ctx.strokeStyle = '#fff';
                                ctx.lineWidth = 3 * zoom;
                                ctx.stroke();
                                
                                ctx.fillStyle = '#fff';
                                ctx.font = `bold ${12 * zoom}px Arial`;
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.fillText('END', toLoc.x * zoom, toLoc.y * zoom);
                            }
                        }
                    }
                    
                    ctx.restore();
                };
                img.src = floorPlan;
            };

            useEffect(() => {
                drawCanvas();
            }, [floorPlan, locations, currentPath, activePath, zoom, offset, pendingLocation, trainingFrom, trainingTo]);

            const handleCanvasClick = (e) => {
                if (!canvasRef.current) return;
                
                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left - offset.x) / zoom;
                const y = (e.clientY - rect.top - offset.y) / zoom;

                if (addingLocation) {
                    setPendingLocation({ x, y });
                } else if (mode === 'train' && isAdmin) {
                    addPathPoint(x, y);
                }
            };

            const zoomIn = () => {
                setZoom(prevZoom => Math.min(prevZoom * 1.2, 5));
            };

            const zoomOut = () => {
                setZoom(prevZoom => Math.max(prevZoom / 1.2, 0.1));
            };

            const resetZoom = () => {
                setZoom(1);
                setOffset({ x: 0, y: 0 });
            };

            const handleMouseDown = (e) => {
                if (e.button !== 0) return;
                setIsDragging(true);
                setDragStart({
                    x: e.clientX - offset.x,
                    y: e.clientY - offset.y
                });
                if (canvasRef.current) {
                    canvasRef.current.style.cursor = 'grabbing';
                }
            };

            const handleMouseMove = (e) => {
                if (!isDragging) return;
                
                const newOffset = {
                    x: e.clientX - dragStart.x,
                    y: e.clientY - dragStart.y
                };
                
                setOffset(newOffset);
            };

            const handleMouseUp = () => {
                setIsDragging(false);
                if (canvasRef.current) {
                    canvasRef.current.style.cursor = 'grab';
                }
            };

            const handleModeChange = (newMode) => {
                if ((newMode === 'view' || newMode === 'train') && !isAdmin) {
                    alert('Admin access required for this mode');
                    return;
                }
                setMode(newMode);
                
                if (newMode !== 'train') {
                    setCurrentPath([]);
                    setPathInstructions([]);
                }
            };

            const startAddingLocation = () => {
                if (!isAdmin) {
                    alert('Admin access required to add locations');
                    return;
                }
                setAddingLocation(true);
                setNewLocationName('');
                setPendingLocation(null);
            };

            const confirmAddLocation = () => {
                if (!newLocationName.trim()) {
                    alert('Please enter a location name');
                    return;
                }
                if (!pendingLocation) {
                    alert('Please click on the floor plan to place the location');
                    return;
                }
                setLocations([...locations, { 
                    name: newLocationName.trim(), 
                    x: pendingLocation.x, 
                    y: pendingLocation.y 
                }]);
                setAddingLocation(false);
                setNewLocationName('');
                setPendingLocation(null);
            };

            const cancelAddLocation = () => {
                setAddingLocation(false);
                setNewLocationName('');
                setPendingLocation(null);
            };

            const nextStep = () => {
                if (!activePath || !isNavigating) return;
                
                const nextIdx = currentStep + 1;
                if (nextIdx < activePath.instructions.length) {
                    setCurrentStep(nextIdx);
                } else {
                    stopNavigation();
                }
            };

            const startTraining = () => {
                setCurrentPath([]);
                setPathInstructions([]);
                setNewPathName('');
                alert('Click on the floor plan to draw a path. Each click adds a point to your path.');
            };
            
            const addPathPoint = (x, y) => {
                if (mode !== 'train' || !isAdmin) return;
                
                setCurrentPath([...currentPath, { x, y }]);
                
                if (currentPath.length > 0) {
                    const newInstruction = `From point ${currentPath.length} to ${currentPath.length + 1}: Continue forward`;
                    setPathInstructions([...pathInstructions, newInstruction]);
                } else {
                    const startInstruction = `Start at coordinates (${Math.round(x)}, ${Math.round(y)})`;
                    setPathInstructions([startInstruction]);
                }
            };
            
            const addInstructionToPath = (instruction) => {
                if (!instruction.trim()) return;
                setPathInstructions([...pathInstructions, instruction]);
                setCurrentInstruction('');
            };
            
            const saveTrainedPath = () => {
                if (!trainingFrom || !trainingTo) {
                    alert('Please select both "From" and "To" locations for this path');
                    return;
                }
                
                if (currentPath.length < 2) {
                    alert('Please draw a path with at least 2 points');
                    return;
                }
                
                if (pathInstructions.length === 0) {
                    alert('Please add at least one instruction for this path');
                    return;
                }
                
                const pathName = newPathName.trim() || `${trainingFrom} to ${trainingTo} Path`;
                
                const newPath = {
                    id: Date.now(),
                    name: pathName,
                    from: trainingFrom,
                    to: trainingTo,
                    path: [...currentPath],
                    instructions: [...pathInstructions],
                    dateCreated: new Date().toISOString(),
                    totalDistance: calculatePathDistance(currentPath),
                    pointCount: currentPath.length
                };
                
                setPaths([...paths, newPath]);
                setCurrentPath([]);
                setPathInstructions([]);
                setNewPathName('');
                setTrainingFrom('');
                setTrainingTo('');
                drawCanvas();
                alert(`Path "${pathName}" saved successfully! You can now use it for navigation.`);
            };
            
            const calculatePathDistance = (pathPoints) => {
                if (pathPoints.length < 2) return 0;
                
                let totalDistance = 0;
                for (let i = 1; i < pathPoints.length; i++) {
                    const dx = pathPoints[i].x - pathPoints[i-1].x;
                    const dy = pathPoints[i].y - pathPoints[i-1].y;
                    totalDistance += Math.sqrt(dx * dx + dy * dy);
                }
                
                return Math.round(totalDistance);
            };

            const clearCurrentPath = () => {
                if (confirm('Clear the current path drawing?')) {
                    setCurrentPath([]);
                    setPathInstructions([]);
                }
            };
            
            const deleteInstruction = (index) => {
                const newInstructions = [...pathInstructions];
                newInstructions.splice(index, 1);
                setPathInstructions(newInstructions);
            };
            
            const editInstruction = (index, newText) => {
                const newInstructions = [...pathInstructions];
                newInstructions[index] = newText;
                setPathInstructions(newInstructions);
            };

            const handleLogin = () => {
                const ADMIN_CREDENTIALS = {
                    username: 'admin',
                    password: 'admin123'
                };
                
                if (username === ADMIN_CREDENTIALS.username && password === ADMIN_CREDENTIALS.password) {
                    setIsAdmin(true);
                    setShowLogin(false);
                    setUsername('');
                    setPassword('');
                    localStorage.setItem('nav-admin', 'true');
                    alert('Admin login successful!');
                } else {
                    alert('Invalid credentials');
                }
            };

            const handleLogout = () => {
                setIsAdmin(false);
                setMode('navigate');
                localStorage.removeItem('nav-admin');
                alert('Logged out successfully');
            };

            const handleFileUpload = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        setFloorPlan(event.target.result);
                        setZoom(1);
                        setOffset({ x: 0, y: 0 });
                    };
                    reader.readAsDataURL(file);
                }
            };

            // =============================================
            // COMPONENTS
            // =============================================
            
            const SchoolNavigationHeader = () => {
                return React.createElement('div', { className: 'school-header' },
                    React.createElement('div', { className: 'school-title' },
                        React.createElement('div', { className: 'school-icon' },
                            React.createElement(SchoolIcon)
                        ),
                        React.createElement('div', null,
                            React.createElement('div', null, 'Emmaus School Navigation System'),
                            React.createElement('div', { className: 'school-subtitle' }, 
                                'Indoor Wayfinding with Live Walk Navigation'
                            )
                        ),
                        React.createElement('div', { className: 'school-badge' },
                            'School Edition'
                        )
                    )
                );
            };
            
            const LocationDropdown = ({ value, onChange, placeholder, disabled }) => {
                return React.createElement('select', {
                    value: value,
                    onChange: (e) => onChange(e.target.value),
                    className: 'w-full mb-2',
                    disabled: disabled
                },
                    React.createElement('option', { value: '' }, placeholder),
                    locations.map((loc, idx) =>
                        React.createElement('option', { key: idx, value: loc.name }, loc.name)
                    )
                );
            };
            
            const NavigationPanel = () => {
                return React.createElement('div', { className: 'navigation-panel' },
                    React.createElement('h3', null, 'Navigation'),
                    
                    React.createElement(LocationDropdown, {
                        value: navigateFrom,
                        onChange: setNavigateFrom,
                        placeholder: 'From...',
                        disabled: isNavigating || isLiveNavigation
                    }),
                    React.createElement(LocationDropdown, {
                        value: navigateTo,
                        onChange: setNavigateTo,
                        placeholder: 'To...',
                        disabled: isNavigating || isLiveNavigation
                    }),
                    
                    !isNavigating && !isLiveNavigation ? (
                        React.createElement('div', null,
                            React.createElement('button', {
                                onClick: startNavigation,
                                className: 'btn-danger w-full mb-2'
                            }, React.createElement(NavigationIcon), ' Start Navigation'),
                            
                            React.createElement('button', {
                                onClick: () => {
                                    if (!navigateFrom || !navigateTo) {
                                        alert('Please select both "From" and "To" locations first');
                                        return;
                                    }
                                    const path = paths.find(p => p.from === navigateFrom && p.to === navigateTo);
                                    if (!path) {
                                        alert('No path found. Please train this path first.');
                                        return;
                                    }
                                    setActivePath(path);
                                    setIsNavigating(false);
                                },
                                className: 'btn-primary w-full'
                            }, React.createElement(WalkIcon), ' Prepare for Live Walk')
                        )
                    ) : (
                        React.createElement('div', null,
                            React.createElement('div', { className: 'instruction-text' },
                                `Navigating: ${navigateFrom} â†’ ${navigateTo}`,
                                React.createElement('br'),
                                isLiveNavigation ? 'Live walk mode active' : `Step ${currentStep + 1}/${activePath.instructions.length}`,
                                React.createElement('br'),
                                !isLiveNavigation && activePath.instructions[currentStep]
                            ),
                            React.createElement('div', { className: 'flex gap-2' },
                                !isLiveNavigation && React.createElement('button', {
                                    onClick: nextStep,
                                    className: 'btn-primary flex-1 text-sm'
                                }, React.createElement(PlayIcon), ' Next Step'),
                                React.createElement('button', {
                                    onClick: () => {
                                        if (isLiveNavigation) {
                                            stopLiveNavigation();
                                        }
                                        stopNavigation();
                                    },
                                    className: 'btn-secondary flex-1 text-sm'
                                }, 'Stop Navigation')
                            )
                        )
                    )
                );
            };

            // =============================================
            // MAIN RENDER
            // =============================================
            
            if (isFullscreenMode) {
                // Fullscreen mode during navigation
                return React.createElement('div', { className: 'fullscreen-mode' },
                    React.createElement('div', { className: 'fullscreen-header' },
                        React.createElement('div', null,
                            React.createElement('strong', null, `Navigating: ${navigateFrom} â†’ ${navigateTo}`),
                            isLiveNavigation && React.createElement('div', { className: 'text-sm' }, 'Live walk mode active')
                        ),
                        React.createElement('div', { className: 'flex gap-2' },
                            React.createElement('button', {
                                onClick: fitCanvasToScreen,
                                className: 'btn-primary text-sm'
                            }, 'Fit to Screen'),
                            React.createElement('button', {
                                onClick: exitFullscreen,
                                className: 'btn-secondary text-sm'
                            }, 'Exit Fullscreen')
                        )
                    ),
                    React.createElement('div', { className: 'fullscreen-canvas' },
                        React.createElement('canvas', {
                            ref: canvasRef,
                            onClick: handleCanvasClick,
                            className: 'cursor-grab'
                        })
                    )
                );
            }
            
            return React.createElement('div', { className: 'app' },
                // Sidebar
                React.createElement('div', { className: `sidebar ${isSidebarCollapsed ? 'collapsed' : ''}` },
                    !isSidebarCollapsed && React.createElement(React.Fragment, null,
                        React.createElement(SchoolNavigationHeader, null),
                        
                        React.createElement('div', { className: 'section' },
                            !isAdmin ? (
                                React.createElement('div', null,
                                    React.createElement('button', {
                                        onClick: () => setShowLogin(true),
                                        className: 'btn-warning w-full'
                                    }, React.createElement(LoginIcon), ' Admin Login'),
                                    showLogin && React.createElement('div', { className: 'login-panel' },
                                        React.createElement('h3', null, 'Admin Login'),
                                        React.createElement('input', {
                                            type: 'text',
                                            value: username,
                                            onChange: (e) => setUsername(e.target.value),
                                            placeholder: 'Username',
                                            className: 'w-full mb-2'
                                        }),
                                        React.createElement('input', {
                                            type: 'password',
                                            value: password,
                                            onChange: (e) => setPassword(e.target.value),
                                            placeholder: 'Password',
                                            className: 'w-full mb-2',
                                            onKeyPress: (e) => e.key === 'Enter' && handleLogin()
                                        }),
                                        React.createElement('div', { className: 'flex gap-2' },
                                            React.createElement('button', {
                                                onClick: handleLogin,
                                                className: 'btn-success flex-1'
                                            }, 'Login'),
                                            React.createElement('button', {
                                                onClick: () => setShowLogin(false),
                                                className: 'btn-secondary flex-1'
                                            }, 'Cancel')
                                        )
                                    )
                                )
                            ) : (
                                React.createElement('button', {
                                    onClick: handleLogout,
                                    className: 'btn-secondary w-full'
                                }, React.createElement(LogoutIcon), ' Logout Admin')
                            )
                        ),

                        React.createElement('div', { className: 'section' },
                            React.createElement('button', {
                                onClick: () => fileInputRef.current?.click(),
                                className: 'btn-primary w-full'
                            }, React.createElement(UploadIcon), ' Upload Floor Plan'),
                            React.createElement('input', {
                                ref: fileInputRef,
                                type: 'file',
                                accept: 'image/*',
                                onChange: handleFileUpload,
                                className: 'hidden'
                            })
                        ),

                        React.createElement('div', { className: 'section' },
                            React.createElement('label', { className: 'text-sm' }, 'Mode:'),
                            React.createElement('div', { className: 'mode-buttons' },
                                React.createElement('button', {
                                    onClick: () => handleModeChange('view'),
                                    className: `mode-btn ${mode === 'view' ? 'active' : ''} ${!isAdmin ? 'disabled' : ''}`,
                                    disabled: !isAdmin
                                }, 'View'),
                                React.createElement('button', {
                                    onClick: () => handleModeChange('train'),
                                    className: `mode-btn train ${mode === 'train' ? 'active' : ''} ${!isAdmin ? 'disabled' : ''}`,
                                    disabled: !isAdmin
                                }, 'Train'),
                                React.createElement('button', {
                                    onClick: () => handleModeChange('navigate'),
                                    className: `mode-btn navigate ${mode === 'navigate' ? 'active' : ''}`
                                }, 'Navigate')
                            )
                        ),

                        mode === 'navigate' && React.createElement(NavigationPanel, null),

                        isAdmin && React.createElement('div', { className: 'section' },
                            React.createElement('div', { className: 'flex justify-between items-center mb-2' },
                                React.createElement('h2', null, 'Manage Locations'),
                                !addingLocation && React.createElement('button', {
                                    onClick: startAddingLocation,
                                    className: 'btn-primary text-sm'
                                }, '+ Add Location')
                            ),
                            
                            addingLocation && React.createElement('div', { className: 'add-location-panel' },
                                React.createElement('h3', { className: 'text-sm' }, 'Add New Location'),
                                React.createElement('input', {
                                    type: 'text',
                                    value: newLocationName,
                                    onChange: (e) => setNewLocationName(e.target.value),
                                    placeholder: 'Enter location name...',
                                    className: 'w-full mb-2',
                                    onKeyPress: (e) => e.key === 'Enter' && confirmAddLocation()
                                }),
                                React.createElement('p', { className: 'text-xs text-gray-600 mb-2' },
                                    pendingLocation ? 'âœ“ Location marked on map' : 'Click on the map to place marker'
                                ),
                                React.createElement('div', { className: 'flex gap-2' },
                                    React.createElement('button', {
                                        onClick: confirmAddLocation,
                                        className: 'btn-success flex-1 text-sm'
                                    }, 'Save'),
                                    React.createElement('button', {
                                        onClick: cancelAddLocation,
                                        className: 'btn-secondary flex-1 text-sm'
                                    }, 'Cancel')
                                )
                            ),
                            
                            React.createElement('div', { className: 'scroll-container' },
                                locations.length === 0 
                                    ? React.createElement('p', { className: 'text-gray-600 text-sm' }, 'No locations added yet')
                                    : locations.map((loc, idx) =>
                                        React.createElement('div', { key: idx, className: 'path-item' },
                                            React.createElement('span', null, loc.name),
                                            React.createElement('button', {
                                                onClick: () => setLocations(locations.filter((_, i) => i !== idx)),
                                                className: 'text-red-500'
                                            }, React.createElement(TrashIcon))
                                        )
                                    )
                            )
                        ),

                        React.createElement('div', { className: 'section' },
                            React.createElement('h2', null, `Saved Paths (${paths.length})`),
                            React.createElement('div', { className: 'scroll-container' },
                                paths.length === 0
                                    ? React.createElement('p', { className: 'text-gray-600 text-sm' }, 'No paths saved yet')
                                    : paths.map((path, idx) =>
                                        React.createElement('div', { 
                                            key: idx, 
                                            className: `path-item ${selectedPathIndex === idx ? 'active' : ''}`,
                                            onClick: () => {
                                                setNavigateFrom(path.from);
                                                setNavigateTo(path.to);
                                                setSelectedPathIndex(idx);
                                            }
                                        },
                                            React.createElement('div', null,
                                                `${path.from} â†’ ${path.to}`,
                                                React.createElement('span', { className: 'text-xs text-gray-600' },
                                                    ` (${path.instructions.length} steps)`
                                                )
                                            )
                                        )
                                    )
                            )
                        )
                    ),
                    
                    // Sidebar toggle button
                    React.createElement('div', {
                        className: 'sidebar-toggle',
                        onClick: toggleSidebar,
                        title: isSidebarCollapsed ? 'Expand Sidebar' : 'Collapse Sidebar'
                    },
                        isSidebarCollapsed ? React.createElement(ExpandIcon) : React.createElement(CollapseIcon)
                    )
                ),

                // Main content
                React.createElement('div', { className: 'main-content' },
                    floorPlan && React.createElement('div', { className: 'zoom-controls' },
                        React.createElement('button', {
                            onClick: zoomOut,
                            className: 'zoom-btn',
                            disabled: zoom <= 0.1
                        }, React.createElement(ZoomOutIcon)),
                        React.createElement('div', { className: 'zoom-level' }, `${Math.round(zoom * 100)}%`),
                        React.createElement('button', {
                            onClick: zoomIn,
                            className: 'zoom-btn',
                            disabled: zoom >= 5
                        }, React.createElement(ZoomInIcon)),
                        React.createElement('button', {
                            onClick: resetZoom,
                            className: 'zoom-btn'
                        }, React.createElement(ResetZoomIcon)),
                        React.createElement('button', {
                            onClick: fitCanvasToScreen,
                            className: 'zoom-btn',
                            title: 'Fit to Screen'
                        }, 'ðŸ”')
                    ),
                    
                    React.createElement('div', { 
                        className: 'canvas-container',
                        onMouseDown: handleMouseDown,
                        onMouseMove: handleMouseMove,
                        onMouseUp: handleMouseUp,
                        onMouseLeave: handleMouseUp
                    },
                        floorPlan 
                            ? React.createElement('canvas', {
                                ref: canvasRef,
                                onClick: handleCanvasClick,
                                className: 'cursor-grab'
                            })
                            : React.createElement('div', { className: 'upload-area' },
                                React.createElement('div', { style: { fontSize: '3rem', marginBottom: '1rem' } }, 'ðŸ“¤'),
                                React.createElement('p', { className: 'text-lg font-semibold mb-2' }, 'Upload Emmaus School Floor Plan'),
                                React.createElement('p', { className: 'text-gray-600 mb-4' }, 'Supported formats: JPG, PNG, GIF, BMP'),
                                React.createElement('button', {
                                    onClick: () => fileInputRef.current?.click(),
                                    className: 'btn-primary px-8 py-3 text-lg'
                                }, 'Choose School Map')
                            )
                    )
                )
            );
        };

        ReactDOM.render(React.createElement(FloorPlanNavigator), document.getElementById('root'));
    </script>
</body>
</html>