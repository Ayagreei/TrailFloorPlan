<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Walk-to-Navigate Demo</title>
  <style>
    :root{
      --bg:#e8f7ff;
      --ground:#d0f0c0;
      --hud-bg: rgba(0,0,0,0.6);
      --hud-color: #fff;
    }
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
    body{background:linear-gradient(180deg,var(--bg) 0%, #ffffff 70%); overflow:hidden;}
    /* World (long horizontal area that we'll translate to create navigation) */
    .viewport{position:relative;width:100%;height:100%;overflow:hidden;}
    .world{
      position:absolute;left:0;top:0;height:100%;
      width:4000px; /* long world — feel free to change */
      display:block;
      transition: transform 120ms linear;
      background:
        linear-gradient(180deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.6) 80%),
        repeating-linear-gradient(0deg, rgba(0,0,0,0.02) 0 1px, transparent 1px 60px);
    }
    /* simple ground line */
    .ground{
      position:absolute;left:0;right:0;bottom:0;height:110px;background:linear-gradient(180deg,var(--ground),#b9e69a);border-top:4px solid rgba(0,0,0,0.06);
    }
    /* small scenery blocks to show movement */
    .world .block{position:absolute;bottom:110px;width:140px;height:90px;background:#fff;border-radius:10px;box-shadow:0 6px 18px rgba(0,0,0,0.08);display:flex;align-items:center;justify-content:center;font-weight:600;color:#333}
    /* the "avatar" image that stays (mostly) centered */
    .avatar{
      position:absolute;
      left:50%; transform:translateX(-50%);
      bottom:110px; /* sits on ground */
      width:48px;height:48px;
      z-index:20;
      transition: transform 80ms linear;
      will-change:transform;
    }
    /* small shadow */
    .avatar::after{
      content:"";position:absolute;left:50%;transform:translateX(-50%);bottom:-8px;width:40px;height:8px;background:rgba(0,0,0,0.12);border-radius:50%;
    }

    /* Heads-up display */
    .hud{
      position:fixed;left:12px;top:12px;padding:10px 12px;background:var(--hud-bg);color:var(--hud-color);border-radius:10px;font-size:14px;z-index:40;
      backdrop-filter: blur(6px);
    }
    .controls{position:fixed;right:12px;top:12px;z-index:40;display:flex;gap:8px;flex-direction:column}
    button{padding:8px 12px;border-radius:8px;border:0;background:#007aff;color:#fff;font-weight:600;box-shadow:0 6px 14px rgba(0,0,0,0.08)}
    .small{padding:6px 8px;font-size:13px}
    .note{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;background:rgba(0,0,0,0.6);color:#fff;padding:8px 12px;border-radius:999px;font-size:13px;z-index:40}
    /* responsive tweaks */
    @media (max-width:420px){
      .world{width:3000px}
      .hud{font-size:13px}
    }
  </style>
</head>
<body>
  <div class="viewport" id="viewport">
    <div class="world" id="world" aria-hidden="true">
      <!-- some simple scenery blocks to visualize movement -->
      <div class="block" style="left:120px">A</div>
      <div class="block" style="left:420px">B</div>
      <div class="block" style="left:860px">C</div>
      <div class="block" style="left:1400px">D</div>
      <div class="block" style="left:2100px">E</div>
      <div class="block" style="left:2800px">F</div>
    </div>

    <!-- Avatar: using inline SVG to keep it tiny and work on all devices -->
    <div class="avatar" id="avatar" aria-hidden="false" title="You">
      <!-- simple walking person icon -->
      <svg viewBox="0 0 24 24" width="48" height="48" xmlns="http://www.w3.org/2000/svg">
        <circle cx="12" cy="3.5" r="2.2" fill="#ffcc66"/>
        <path d="M8 21c0-2 2-5 4-5s4 3 4 5" fill="#ffcc66"/>
        <path d="M6 12c1.5 0 2.6-1.2 2.6-2.6S7.5 6.8 6 6.8 3.4 8 3.4 9.4 4.5 12 6 12z" fill="#ff7a66"/>
        <path d="M12 8.5l3 3-1.5 3" stroke="#333" stroke-linecap="round" stroke-linejoin="round" stroke-width="0.9" fill="none" />
      </svg>
    </div>

    <div class="ground" aria-hidden="true"></div>
  </div>

  <div class="hud" id="hud">
    <div>Steps: <strong id="steps">0</strong></div>
    <div>Distance: <strong id="distance">0.0</strong> m</div>
    <div id="status" style="margin-top:6px;font-size:12px;opacity:0.9">Sensor: unknown</div>
  </div>

  <div class="controls" id="controls">
    <button id="request-perm" class="small">Enable Motion (iOS)</button>
    <button id="simulate-step" class="small">Simulate Step</button>
    <button id="reset" class="small">Reset</button>
  </div>

  <div class="note" id="note">Tip: This demo uses motion sensors. On iOS open over HTTPS and tap "Enable Motion (iOS)". Use keyboard arrows or "Simulate Step" as fallback.</div>

  <script>
    // Walk-to-Navigate demo
    // Works on iOS/Safari and other browsers with permission handling.
    // Fallback: keyboard arrows and on-screen button.
    (function(){
      const world = document.getElementById('world');
      const avatar = document.getElementById('avatar');
      const stepsEl = document.getElementById('steps');
      const distanceEl = document.getElementById('distance');
      const statusEl = document.getElementById('status');
      const permBtn = document.getElementById('request-perm');
      const simulateBtn = document.getElementById('simulate-step');
      const resetBtn = document.getElementById('reset');

      // state
      let posPx = 0;              // how far we've moved in px within the world
      const pxPerMeter = 60;     // scaling: 1 meter of walking ~ 60 pixels (adjustable)
      let stepCount = 0;
      let distanceMeters = 0;

      // step detection vars
      let lastMag = 0;
      let lastStepTime = 0;
      const minStepInterval = 300; // ms between accepted steps
      let threshold = 1.2; // acceleration delta threshold for detecting a step (m/s^2)
      let listening = false;

      function updateHUD(){
        stepsEl.textContent = stepCount;
        distanceEl.textContent = (distanceMeters).toFixed(2);
      }

      function clampWorld(){
        // keep world transform within its bounds
        const maxShift = world.offsetWidth - window.innerWidth;
        if (posPx < 0) posPx = 0;
        if (posPx > maxShift) posPx = maxShift;
      }

      function render(){
        clampWorld();
        // Move world left as user "walks" so avatar appears to move forward
        world.style.transform = `translateX(${-posPx}px)`;
        // subtle avatar bob on step (animated via transform)
        // handled in stepAnimation()
      }

      function stepAnimation(){
        avatar.style.transform = 'translateX(-50%) translateY(-6px) scale(1.02)';
        setTimeout(()=> avatar.style.transform = 'translateX(-50%) translateY(0) scale(1)', 130);
      }

      function onStepDetected(strideMeters = 0.75){
        const now = Date.now();
        if (now - lastStepTime < minStepInterval) return;
        lastStepTime = now;

        stepCount += 1;
        distanceMeters += strideMeters;
        // move px according to stride and scaling
        const movePx = strideMeters * pxPerMeter;
        posPx += movePx;
        updateHUD();
        stepAnimation();
        render();
      }

      // DeviceMotion handler: simple peak detection on acceleration magnitude
      function handleMotion(e){
        // Use accelerationIncludingGravity or acceleration depending on device
        const a = e.acceleration || e.accelerationIncludingGravity;
        if (!a) return;
        // some devices supply nulls; default to zeros
        const ax = a.x || 0;
        const ay = a.y || 0;
        const az = a.z || 0;

        // magnitude (m/s^2)
        const mag = Math.sqrt(ax*ax + ay*ay + az*az);
        const delta = Math.abs(mag - lastMag);

        // debug: adjust threshold dynamically? For simplicity we use fixed.
        if (delta > threshold){
          onStepDetected(0.7 + Math.random()*0.3); // approximate stride between 0.7-1.0 m
        }
        lastMag = mag;
      }

      // Permission handling for iOS Safari (DeviceMotionEvent.requestPermission)
      async function requestMotionPermission(){
        if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
          try {
            const resp = await DeviceMotionEvent.requestPermission();
            if (resp === 'granted') {
              startListening();
              statusEl.textContent = 'Sensor: motion granted';
              permBtn.style.display = 'none';
            } else {
              statusEl.textContent = 'Sensor: permission denied';
            }
          } catch (err){
            statusEl.textContent = 'Sensor: permission error';
            console.error(err);
          }
        } else {
          // Non iOS devices don't require explicit permission in that way
          statusEl.textContent = 'Sensor: requesting (non-iOS)';
          startListening();
          permBtn.style.display = 'none';
        }
      }

      function startListening(){
        if (listening) return;
        if ('ondevicemotion' in window) {
          window.addEventListener('devicemotion', handleMotion, {passive:true});
          listening = true;
          statusEl.textContent = 'Sensor: listening to devicemotion';
        } else {
          statusEl.textContent = 'Sensor: devicemotion not available';
        }
      }

      function stopListening(){
        if (!listening) return;
        window.removeEventListener('devicemotion', handleMotion);
        listening = false;
        statusEl.textContent = 'Sensor: stopped';
      }

      // Fallback controls
      simulateBtn.addEventListener('click', ()=> onStepDetected(0.75));
      permBtn.addEventListener('click', requestMotionPermission);
      resetBtn.addEventListener('click', ()=>{
        posPx = 0; stepCount = 0; distanceMeters = 0; updateHUD(); render();
      });

      // Keyboard arrows fallback for desktop
      window.addEventListener('keydown', (ev)=>{
        if (ev.key === 'ArrowRight') { posPx += 40; render(); }
        if (ev.key === 'ArrowLeft') { posPx -= 40; render(); }
        if (ev.key === ' ') { onStepDetected(0.75); } // space simulates step
      });

      // Provide an initial attempt to start listening on non-iOS devices (browsers that allow it)
      // but we require a user gesture on iOS to call requestPermission.
      if (!(typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function')) {
        // Not iOS requiring explicit permission — start listening right away
        startListening();
        permBtn.style.display = 'none';
      } else {
        // iOS: keep the button visible and wait for user to tap it (https requirement)
        statusEl.textContent = 'Sensor: tap "Enable Motion (iOS)" (works only on HTTPS)';
      }

      // Small UI: allow adjusting threshold via long-press (hidden convenience)
      let longpressTimer;
      statusEl.addEventListener('pointerdown', ()=>{
        longpressTimer = setTimeout(()=>{
          const v = prompt('Adjust step detection threshold (current '+threshold+'). Lower=more sensitive. Typical: 0.8–2.5', String(threshold));
          const nv = parseFloat(v);
          if (!isNaN(nv)) { threshold = nv; alert('threshold set to '+threshold); }
        }, 700);
      });
      statusEl.addEventListener('pointerup', ()=> clearTimeout(longpressTimer));
      statusEl.addEventListener('pointerleave', ()=> clearTimeout(longpressTimer));

      // Initial render and HUD
      updateHUD(); render();

      // Explain HTTPS requirement in console for quick help
      console.info('Walk-to-Navigate demo: For motion sensors on iOS Safari, open this page over HTTPS and tap "Enable Motion (iOS)". If sensors are unavailable, use "Simulate Step" or keyboard.')
    })();
  </script>
</body>
</html>